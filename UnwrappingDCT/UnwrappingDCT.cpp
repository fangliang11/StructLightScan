///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.11.0.1
// Non-ASCII strings in this file are encoded in UTF-8.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////


#include <iostream>
#include <time.h>
#include <random>
#include <algorithm>
#include <cmath>
#include <vector>

#include "fftw3.h"
#include "HalconCpp.h"
#include "HDevThread.h"


#define PI 3.1415926

using namespace HalconCpp;


int ImageDCT(HalconCpp::HImage* img_in, HalconCpp::HImage* img_out)
{
	//std::wstring imgname = L"E:\\检测与装备事业部\\国防科大三维扫描\\算法开发\\秦司益数据右\\def\\0.bmp";
	//HalconCpp::HImage img_in;
	//HalconCpp::ReadImage(img_in, (HalconCpp::HTuple)(imgname.c_str()));
	HalconCpp::HString hs_type;
	Hlong hl_width, hl_height;
	void* ptr = img_in->GetImagePointer1(&hs_type, &hl_width, &hl_height);
	if (ptr == nullptr) {
		std::cout << "read image error\n";
		return -1;
	}

	unsigned char* pdata = static_cast<unsigned char*>(ptr);
	const int width = (const int)hl_width;
	const int height = (const int)hl_height;

	/*
	*fftw_complex 是FFTW自定义的复数类
	*引入<complex>则会使用STL的复数类
	*/
	const int rows = height;
	const int columns = width;
	const int N = 2 * rows;
	const int M = 2 * columns;
	// 1.定义 DCT 的输入与输出 ，real型
	double* input_arry = (double *)fftw_malloc(sizeof(double) * rows * columns);
	double* dct_arry = (double *)fftw_malloc(sizeof(double) * rows * columns);
	double* idct_arry = (double *)fftw_malloc(sizeof(double) * rows * columns);

	// 拷贝像素数据
	const int wide_step = ((width * 8 / 8 + 3) / 4) * 4;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			input_arry[i * width + j] = pdata[i * wide_step + j];
		}
	}

	// 2.定义plan，包含序列长度(行，列)、输入序列、输出序列、变换方向、变换模式
	//   DCT可认为实偶对称数据的DFT，  REDFTab
	fftw_plan plan_dct = fftw_plan_r2r_2d(rows, columns, input_arry, dct_arry, FFTW_REDFT10, FFTW_REDFT10, FFTW_ESTIMATE);
	fftw_plan plan_idct = fftw_plan_r2r_2d(rows, columns, dct_arry, idct_arry, FFTW_REDFT01, FFTW_REDFT01, FFTW_ESTIMATE);

	// 3. 执行plan，对于每个plan，应当"一次定义 多次使用"，同一plan的运算速度极快
	//    DCT
	fftw_execute_r2r(plan_dct, input_arry, dct_arry);
	std::cout << "\nDCT2D:" << std::endl;
	clock_t start, finish;
	double* dct_conv_array = (double *)fftw_malloc(sizeof(double) * rows * columns);
	start = clock();
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			dct_conv_array[i * columns + j] = dct_arry[i * columns + j] / (std::sqrt(N) * std::sqrt(M));
			if (i == 0)
				dct_conv_array[i * columns + j] = dct_conv_array[i * columns + j] / std::sqrt(2.0);
			if (j == 0)
				dct_conv_array[i * columns + j] = dct_conv_array[i * columns + j] / std::sqrt(2.0);

			std::cout << dct_conv_array[i * columns + j] << "  ";
			if (j == 9)
				std::cout << "\n";
		}
	}
	finish = clock();
	std::cout << "DCT total time(s) = " << (double)(finish - start) / 1000.0 << std::endl;

	//    IDCT
	//  解相位
	int R = 2; // lamda
	double fenzi = 0.0;
	double top_left = dct_arry[0];
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			//  方法1
			//fenzi = 2 * (std::cos(PI * i / rows) + std::cos(PI * j / columns) - 2);

			//  方法2
			fenzi = (2 + 16 * R)*(std::cos(PI * i / rows) + std::cos(PI * j / columns)) -
				2 * R*(std::cos(2 * PI * i / rows) + std::cos(2 * PI * j / columns)) -
				8 * R*std::cos(PI * i / rows) * std::cos(PI * j / columns) -
				20 * R - 4;
			dct_arry[i * columns + j] = dct_arry[i * columns + j] / fenzi;
		}
	}
	dct_arry[0] = top_left;

	fftw_execute_r2r(plan_idct, dct_arry, idct_arry);
	std::cout << "\nIDCT2D:" << std::endl;
	double* idct_conv_array = (double *)fftw_malloc(sizeof(double) * rows * columns);
	start = clock();
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			idct_conv_array[i * columns + j] = idct_arry[i * columns + j] / (N * M);

			std::cout << idct_conv_array[i * columns + j] << "  ";
			if (j == 9)
				std::cout << "\n";
		}
	}
	finish = clock();
	std::cout << "IDCT total time(s) = " << (double)(finish - start) / 1000.0 << std::endl;


	// 4.销毁plan
	fftw_destroy_plan(plan_dct);
	fftw_destroy_plan(plan_idct);
	fftw_free(input_arry);
	fftw_free(dct_arry);
	fftw_free(idct_arry);
	fftw_free(dct_conv_array);
	fftw_free(idct_conv_array);

	return 0;
}


int ImageDCT(std::vector<double> vecin, std::vector<double> &vecout, int rows, int columns)
{
	/*
	*fftw_complex 是FFTW自定义的复数类
	*引入<complex>则会使用STL的复数类
	*/
	const int N = 2 * rows;
	const int M = 2 * columns;
	// 1.定义 DCT 的输入与输出 ，real型
	double* input_arry = (double *)fftw_malloc(sizeof(double) * rows * columns);
	double* dct_arry = (double *)fftw_malloc(sizeof(double) * rows * columns);
	double* idct_arry = (double *)fftw_malloc(sizeof(double) * rows * columns);

	// 拷贝像素数据
	for (int i = 0; i < rows*columns; i++)
		input_arry[i] = vecin.at(i);

	// 2.定义plan，包含序列长度(行，列)、输入序列、输出序列、变换方向、变换模式
	//   DCT可认为实偶对称数据的DFT，  REDFTab
	fftw_plan plan_dct = fftw_plan_r2r_2d(rows, columns, input_arry, dct_arry, FFTW_REDFT10, FFTW_REDFT10, FFTW_ESTIMATE);
	fftw_plan plan_idct = fftw_plan_r2r_2d(rows, columns, dct_arry, idct_arry, FFTW_REDFT01, FFTW_REDFT01, FFTW_ESTIMATE);

	// 3. 执行plan，对于每个plan，应当"一次定义 多次使用"，同一plan的运算速度极快
	//    DCT
	clock_t start, finish;
	start = clock();
	fftw_execute_r2r(plan_dct, input_arry, dct_arry);
	finish = clock();
	std::cout << "DCT total time(s) = " << (double)(finish - start) / 1000.0 << std::endl;

	//    IDCT
	//  解相位
	int R = 2; // lamda
	double fenzi = 0.0;
	double top_left = dct_arry[0];
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			fenzi = (2 + 16 * R)*(std::cos(PI * i / rows) + std::cos(PI * j / columns)) -
				2 * R*(std::cos(2 * PI * i / rows) + std::cos(2 * PI * j / columns)) -
				8 * R*std::cos(PI * i / rows) * std::cos(PI * j / columns) -
				20 * R - 4;
			dct_arry[i * columns + j] = dct_arry[i * columns + j] / fenzi;
		}
	}
	dct_arry[0] = top_left;

	start = clock();
	fftw_execute_r2r(plan_idct, dct_arry, idct_arry);
	finish = clock();
	std::cout << "IDCT total time(s) = " << (double)(finish - start) / 1000.0 << std::endl;
	// 结果处理
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			vecout.push_back(idct_arry[i * columns + j] / (N * M));
			//vecout->at(i*columns + j) = idct_arry[i * columns + j] / (N * M);
		}
	}

	// 4.销毁plan
	fftw_destroy_plan(plan_dct);
	fftw_destroy_plan(plan_idct);
	fftw_free(input_arry);
	fftw_free(dct_arry);
	fftw_free(idct_arry);

	return 0;
}

// 均值
double average(double* arry, int len)
{
	double sum = 0.0;
	for (int i = 0; i < len; i++) {
		sum += *(arry + i);
	}
	return sum / len;
}

// 方差
double variance(double* arry, int len)
{
	double sum = 0.0;
	double ave = average(arry, len);
	for (int i = 0; i < len; i++) {
		sum += std::pow(*(arry + i) - ave, 2);
	}
	return sum / len;
}

// 标准差
double stdeviation(double* arry, int len)
{
	return std::sqrt(variance(arry, len));
}

// 计算包裹相位
void calWrapPhase(unsigned char * pinput, std::vector<double> &output, int rows, int columns)
{
	const int cycle = 23;
	int half_cycle = cycle / 2;
	double kmeans = 2.0 / 255.0;
	double arry_sub[cycle] = { 0 };
	double iiii = 0;
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			std::vector<double> vecsub;
			if (j <= half_cycle) {
				for (int k = 0; k < 23; k++) 
					arry_sub[k] = (double)*(pinput + i*columns + k);
			}
			else if (j >= columns - half_cycle) {
				for (int k = 0; k < 23; k++)
					arry_sub[k] = (double)*(pinput + i * columns + (columns-cycle) + k);
			}
			else {
				for (int k = 0; k < 23; k++)
					arry_sub[k] = (double)*(pinput + i * columns + (j - half_cycle) + k);
			}
			iiii = ((double)*(pinput + i * columns + j) - average(arry_sub, cycle) - 128.0) / stdeviation(arry_sub, cycle) * kmeans;
			output.push_back(iiii);
		}
	}
}

// 解包裹
int imgUnwrapping(std::vector<double> input, std::vector<double> &output, int rows, int columns, double threshold)
{
	//正弦条纹图像相位展开（解包裹）
	int state = 0;
	//1.计算梯度
	// 包裹相位沿x方向的斜率（梯度）
	std::vector<double> vecdx, vecdy, vecpossion;
	double dx = 0.0;
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			if (j < columns - 1) {
				//double value1 = input.at(i * columns + j + 1);
				//double value2 = input.at(i * columns + j);
				//dx = value1 - value2;
				dx = input.at(i * columns + j + 1) - input.at(i * columns + j);
			}
			else
				dx = 0.0;

			if (dx > threshold)
				dx = dx - 2 * PI;
			else if (dx < -threshold)
				dx = dx + 2 * PI;

			vecdx.push_back(dx);
		}
	}
	// 包裹相位沿y方向的斜率（梯度）
	double dy = 0.0;
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			if (i < rows - 1)
				dy = input.at((i + 1) * columns + j) - input.at(i * columns + j);
			else
				dy = 0.0;

			if (dy > threshold)
				dy = dy - 2 * PI;
			else if (dy < -threshold)
				dy = dy + 2 * PI;

			vecdy.push_back(dy);
		}
	}

	//2.离散泊松方程
	double possion = 0.0;
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			if (i == 0 && j == 0)
				possion = vecdx.at(0) + vecdy.at(0);
			else if (i == 0 && j != 0)
				possion = (vecdx.at(j) - vecdx.at(j - 1)) + vecdy.at(j);
			else if (i != 0 && j == 0)
				possion = vecdx.at(i * columns) + (vecdy.at(i * columns) - vecdy.at((i - 1) * columns));
			else
				possion = vecdx.at(i * columns + j) - vecdx.at(i * columns + j - 1) +
				vecdy.at(i * columns + j) - vecdy.at((i - 1) * columns + j);

			vecpossion.push_back(possion);
		}
	}
	   
	//3. DCT变换   二维离散余弦变换
	//4. 解出相位值
	//5. IDCT变换    离散余弦逆变换, 得到相位的最小二乘解
	state = ImageDCT(vecpossion, output, rows, columns);

	return state;
}


void action()
{
	HImage  ho_Image, ho_Source1, ho_Source2, ho_Source3, ho_Source4;
	HImage  ho_Image1, ho_Image2, ho_Image3, ho_Image4;
	HTuple  hv_Width, hv_Height, hv_WindowHandle;

	if (HDevWindowStack::IsOpen())
		CloseWindow(HDevWindowStack::Pop());

	std::wstring def_path = L"E:\\检测与装备事业部\\国防科大三维扫描\\算法开发\\秦司益数据右\\def\\";
	std::wstring ref_path = L"E:\\检测与装备事业部\\国防科大三维扫描\\算法开发\\秦司益数据右\\ref2\\";

	ReadImage(&ho_Image, (HTuple)ref_path.c_str() + "1.bmp");
	GetImageSize(ho_Image, &hv_Width, &hv_Height);
	SetWindowAttr("background_color", "black");
	OpenWindow(0, 0, 0.5*hv_Width, 0.5*hv_Height, 0, "visible", "", &hv_WindowHandle);
	HDevWindowStack::Push(hv_WindowHandle);
	if (HDevWindowStack::IsOpen())
		DispObj(ho_Image, HDevWindowStack::GetActive());

	//参考图像，标定
	ReadImage(&ho_Source1, (HTuple)ref_path.c_str() + "1.bmp");
	ReadImage(&ho_Source2, (HTuple)ref_path.c_str() + "2.bmp");
	ReadImage(&ho_Source3, (HTuple)ref_path.c_str() + "3.bmp");
	ReadImage(&ho_Source4, (HTuple)ref_path.c_str() + "4.bmp");
	HalconCpp::HString hs_type;
	Hlong hl_width, hl_height;
	void* psource1 = ho_Source1.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	void* psource2 = ho_Source2.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	void* psource3 = ho_Source3.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	void* psource4 = ho_Source4.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	const int rows = (int)hl_height;
	const int columns = (int)hl_width;
	int wide_step = (((int)hl_width * 8 / 8 + 3) / 4) * 4;  // 图像宽度最好为4的倍数
	////使用数组来初始化 vector 对象，只需要 指明拷贝区域的首元素地址和尾后地址就可以了
	//std::vector<double> vecSource1(psource1, psource1 + height * wide_step + 1);
	//std::vector<double> vecSource2(psource2, psource2 + height * wide_step);
	//std::vector<double> vecSource3(psource3, psource3 + height * wide_step);
	//std::vector<double> vecSource4(psource4, psource4 + height * wide_step);

	// 计算参考图像相位: phy=arctan(I4-I2 / I1-I3)
	std::vector<double> vecPhaseSource, vecPhaseUnwrapS;
	std::vector<double> vec_i1, vec_i2, vec_i3, vec_i4;
	calWrapPhase(static_cast<unsigned char*>(psource1), vec_i1, rows, columns);
	calWrapPhase(static_cast<unsigned char*>(psource2), vec_i2, rows, columns);
	calWrapPhase(static_cast<unsigned char*>(psource3), vec_i3, rows, columns);
	calWrapPhase(static_cast<unsigned char*>(psource4), vec_i4, rows, columns);
	double i1 = 0.0, i2 = 0.0, i3 = 0.0, i4 = 0.0;
	for (int i = 0; i < rows*columns; i++) {
		i1 = vec_i1.at(i);
		i2 = vec_i2.at(i);
		i3 = vec_i3.at(i);
		i4 = vec_i4.at(i);
		if (i4 > i2) {
			if (i1 > i3)
				vecPhaseSource.push_back(std::atan((i4 - i2) / (i1 - i3)));
			else if (i1 < i3)
				vecPhaseSource.push_back(std::atan((i4 - i2) / (i1 - i3)) + PI);
			else
				vecPhaseSource.push_back(1 / 2 * PI);
		}
		else if (i4 < i2) {
			if (i1 > i3)
				vecPhaseSource.push_back(std::atan((i4 - i2) / (i1 - i3)) + 2*PI);
			else if (i1 < i3)
				vecPhaseSource.push_back(std::atan((i4 - i2) / (i1 - i3)) + PI);
			else
				vecPhaseSource.push_back(3 / 2 * PI);
		}
		else {
			if (i1 > i3)
				vecPhaseSource.push_back(0.0);
			else
				vecPhaseSource.push_back(PI);
		}
	}

	//相位解包裹
	try {
		imgUnwrapping(vecPhaseSource, vecPhaseUnwrapS, rows, columns, PI);
	}
	catch (const char* errmsg) {
		std::cerr << errmsg << std::endl;
	}

	//待测图像
	ReadImage(&ho_Image1, (HTuple)def_path.c_str() + "1.bmp");
	ReadImage(&ho_Image2, (HTuple)def_path.c_str() + "2.bmp");
	ReadImage(&ho_Image3, (HTuple)def_path.c_str() + "3.bmp");
	ReadImage(&ho_Image4, (HTuple)def_path.c_str() + "4.bmp");
	void* pmeature1 = ho_Image1.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	void* pmeature2 = ho_Image2.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	void* pmeature3 = ho_Image3.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	void* pmeature4 = ho_Image4.GetImagePointer1(&hs_type, &hl_width, &hl_height);
	std::vector<double> vecPhaseMeature, vecPhaseUnwrapM;
	vec_i1.clear();
	vec_i2.clear();
	vec_i3.clear();
	vec_i4.clear();
	calWrapPhase(static_cast<unsigned char*>(pmeature1), vec_i1, rows, columns);
	calWrapPhase(static_cast<unsigned char*>(pmeature2), vec_i2, rows, columns);
	calWrapPhase(static_cast<unsigned char*>(pmeature3), vec_i3, rows, columns);
	calWrapPhase(static_cast<unsigned char*>(pmeature4), vec_i4, rows, columns);
	for (int i = 0; i < rows*columns; i++) {
		i1 = vec_i1.at(i);
		i2 = vec_i2.at(i);
		i3 = vec_i3.at(i);
		i4 = vec_i4.at(i);
		if (i4 > i2) {
			if (i1 > i3)
				vecPhaseMeature.push_back(std::atan((i4 - i2) / (i1 - i3)));
			else if (i1 < i3)
				vecPhaseMeature.push_back(std::atan((i4 - i2) / (i1 - i3)) + PI);
			else
				vecPhaseMeature.push_back(1 / 2 * PI);
		}
		else if (i4 < i2) {
			if (i1 > i3)
				vecPhaseMeature.push_back(std::atan((i4 - i2) / (i1 - i3)) + 2 * PI);
			else if (i1 < i3)
				vecPhaseMeature.push_back(std::atan((i4 - i2) / (i1 - i3)) + PI);
			else
				vecPhaseMeature.push_back(3 / 2 * PI);
		}
		else {
			if (i1 > i3)
				vecPhaseMeature.push_back(0.0);
			else
				vecPhaseMeature.push_back(PI);
		}
	}
	
	try {
		imgUnwrapping(vecPhaseMeature, vecPhaseUnwrapM, rows, columns, PI);
	}
	catch (const char* errmsg) {
		std::cerr << errmsg << std::endl;
	}

	//计算被测物体相位
	std::vector<double> vecPhase;
	//for(auto& phase : vecPhase)
	for (int i = 0; i < rows*columns; i++) {
		vecPhase.push_back(vecPhaseUnwrapM.at(i) - vecPhaseUnwrapS.at(i));
	}

	//double test[256];
	//for (int i = 0; i < 16; i++) {
	//	for (int j = 0; j < 16; j++) {
	//		test[i * 16 + j] = vecPhase.at((i + 280)*columns + j + 900);
	//	}
	//}
	//std::vector<double> vecCut;
	//for (int i = 0; i < rows; i++) {
	//	for (int j = 0; j < columns; j++) {
	//		if (i > 300 && i < 400) {
	//			if (j > 660 && j < 760)
	//				vecCut.push_back(vecPhase.at(i * columns + j));
	//		}
	//	}
	//}


	int pause = 0;
}


int main(int argc, char *argv[])
{
	int ret = 0;

	try
	{
		SetSystem("use_window_thread", "true");

		// Default settings used in HDevelop (can be omitted)
		SetSystem("width", 512);
		SetSystem("height", 512);


		action();

	}
	catch (HException &exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char *)exception.ProcName(),
			(const char *)exception.ErrorMessage());
		ret = 1;
	}

	std::cout << "\nPress Enter to exit..." << std::endl;
	std::cin.get();

	return ret;
}